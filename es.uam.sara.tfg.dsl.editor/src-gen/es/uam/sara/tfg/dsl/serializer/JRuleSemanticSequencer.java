/*
 * generated by Xtext 2.9.2
 */
package es.uam.sara.tfg.dsl.serializer;

import com.google.inject.Inject;
import es.uam.sara.tfg.dsl.services.JRuleGrammarAccess;
import java.util.Set;
import javaRule.And;
import javaRule.AttributeType;
import javaRule.BlendModifiers;
import javaRule.Constructor;
import javaRule.Conteins;
import javaRule.Element;
import javaRule.HaveConstant;
import javaRule.Implements;
import javaRule.Initialize;
import javaRule.IsExtended;
import javaRule.IsInheritor;
import javaRule.JavaDoc;
import javaRule.JavaRulePackage;
import javaRule.Modifiers;
import javaRule.Name;
import javaRule.NoEmpty;
import javaRule.Or;
import javaRule.Parametre;
import javaRule.Return;
import javaRule.Rule;
import javaRule.RuleSet;
import javaRule.Testing;
import javaRule.Variable;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class JRuleSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private JRuleGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == JavaRulePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case JavaRulePackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case JavaRulePackage.ATTRIBUTE_TYPE:
				sequence_AttributeType(context, (AttributeType) semanticObject); 
				return; 
			case JavaRulePackage.BLEND_MODIFIERS:
				sequence_BlendModifiers(context, (BlendModifiers) semanticObject); 
				return; 
			case JavaRulePackage.CONSTRUCTOR:
				sequence_Constructor(context, (Constructor) semanticObject); 
				return; 
			case JavaRulePackage.CONTEINS:
				sequence_Conteins(context, (Conteins) semanticObject); 
				return; 
			case JavaRulePackage.ELEMENT:
				sequence_Element(context, (Element) semanticObject); 
				return; 
			case JavaRulePackage.HAVE_CONSTANT:
				sequence_HaveConstant(context, (HaveConstant) semanticObject); 
				return; 
			case JavaRulePackage.IMPLEMENTS:
				sequence_Implements(context, (Implements) semanticObject); 
				return; 
			case JavaRulePackage.INITIALIZE:
				sequence_Initialize(context, (Initialize) semanticObject); 
				return; 
			case JavaRulePackage.IS_EXTENDED:
				sequence_IsExtended(context, (IsExtended) semanticObject); 
				return; 
			case JavaRulePackage.IS_INHERITOR:
				sequence_IsInheritor(context, (IsInheritor) semanticObject); 
				return; 
			case JavaRulePackage.JAVA_DOC:
				sequence_JavaDoc(context, (JavaDoc) semanticObject); 
				return; 
			case JavaRulePackage.MODIFIERS:
				sequence_Modifiers(context, (Modifiers) semanticObject); 
				return; 
			case JavaRulePackage.NAME:
				sequence_Name(context, (Name) semanticObject); 
				return; 
			case JavaRulePackage.NO_EMPTY:
				sequence_NoEmpty(context, (NoEmpty) semanticObject); 
				return; 
			case JavaRulePackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case JavaRulePackage.PARAMETRE:
				sequence_Parametre(context, (Parametre) semanticObject); 
				return; 
			case JavaRulePackage.RETURN:
				sequence_Return(context, (Return) semanticObject); 
				return; 
			case JavaRulePackage.RULE:
				sequence_Rule(context, (Rule) semanticObject); 
				return; 
			case JavaRulePackage.RULE_SET:
				sequence_RuleSet(context, (RuleSet) semanticObject); 
				return; 
			case JavaRulePackage.TESTING:
				sequence_Testing(context, (Testing) semanticObject); 
				return; 
			case JavaRulePackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     And returns And
	 *
	 * Constraint:
	 *     (op+=Satisfy op+=Satisfy*)
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Satisfy returns AttributeType
	 *     AttributeType returns AttributeType
	 *
	 * Constraint:
	 *     Type=EString
	 */
	protected void sequence_AttributeType(ISerializationContext context, AttributeType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JavaRulePackage.Literals.ATTRIBUTE_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavaRulePackage.Literals.ATTRIBUTE_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeTypeAccess().getTypeEStringParserRuleCall_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BlendModifiers returns BlendModifiers
	 *
	 * Constraint:
	 *     (
	 *         (access=AccessModifier static?='and static'? final?='and final'? abstract?='and abstract'? synchronized?='and synchronized'?) | 
	 *         (static?='static' final?='and final'? abstract?='and abstract'? synchronized?='and synchronized'?) | 
	 *         (final?='final' abstract?='and abstract'? synchronized?='and synchronized'?) | 
	 *         (abstract?='abstract' synchronized?='and synchronized'?) | 
	 *         synchronized?='synchronized'
	 *     )
	 */
	protected void sequence_BlendModifiers(ISerializationContext context, BlendModifiers semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Satisfy returns Constructor
	 *     Constructor returns Constructor
	 *
	 * Constraint:
	 *     {Constructor}
	 */
	protected void sequence_Constructor(ISerializationContext context, Constructor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Satisfy returns Conteins
	 *     Conteins returns Conteins
	 *
	 * Constraint:
	 *     which=Testing
	 */
	protected void sequence_Conteins(ISerializationContext context, Conteins semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JavaRulePackage.Literals.CONTEINS__WHICH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavaRulePackage.Literals.CONTEINS__WHICH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConteinsAccess().getWhichTestingParserRuleCall_2_0(), semanticObject.getWhich());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Element
	 *
	 * Constraint:
	 *     (element=ElementJava filter=Or?)
	 */
	protected void sequence_Element(ISerializationContext context, Element semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Satisfy returns HaveConstant
	 *     HaveConstant returns HaveConstant
	 *
	 * Constraint:
	 *     {HaveConstant}
	 */
	protected void sequence_HaveConstant(ISerializationContext context, HaveConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Satisfy returns Implements
	 *     Implements returns Implements
	 *
	 * Constraint:
	 *     maxInterface=EBigInteger?
	 */
	protected void sequence_Implements(ISerializationContext context, Implements semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Satisfy returns Initialize
	 *     Initialize returns Initialize
	 *
	 * Constraint:
	 *     {Initialize}
	 */
	protected void sequence_Initialize(ISerializationContext context, Initialize semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Satisfy returns IsExtended
	 *     IsExtended returns IsExtended
	 *
	 * Constraint:
	 *     isExtends?='is extends'
	 */
	protected void sequence_IsExtended(ISerializationContext context, IsExtended semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JavaRulePackage.Literals.IS_EXTENDED__IS_EXTENDS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavaRulePackage.Literals.IS_EXTENDED__IS_EXTENDS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIsExtendedAccess().getIsExtendsIsExtendsKeyword_0(), semanticObject.isIsExtends());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Satisfy returns IsInheritor
	 *     IsInheritor returns IsInheritor
	 *
	 * Constraint:
	 *     maxLevel=EBigInteger?
	 */
	protected void sequence_IsInheritor(ISerializationContext context, IsInheritor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Satisfy returns JavaDoc
	 *     JavaDoc returns JavaDoc
	 *
	 * Constraint:
	 *     (
	 *         author?='@author'? 
	 *         parametre?='@parameter'? 
	 *         return?='@return'? 
	 *         version?='@version'? 
	 *         throws?='@throws'? 
	 *         see?='@see'?
	 *     )
	 */
	protected void sequence_JavaDoc(ISerializationContext context, JavaDoc semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Satisfy returns Modifiers
	 *     Modifiers returns Modifiers
	 *
	 * Constraint:
	 *     (blend+=BlendModifiers blend+=BlendModifiers*)
	 */
	protected void sequence_Modifiers(ISerializationContext context, Modifiers semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Satisfy returns Name
	 *     Name returns Name
	 *
	 * Constraint:
	 *     ((type=NameType (operator=NameOperator name=EString)?) | (operator=NameOperator name=EString type=NameType?))
	 */
	protected void sequence_Name(ISerializationContext context, Name semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Satisfy returns NoEmpty
	 *     NoEmpty returns NoEmpty
	 *
	 * Constraint:
	 *     {NoEmpty}
	 */
	protected void sequence_NoEmpty(ISerializationContext context, NoEmpty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Or returns Or
	 *
	 * Constraint:
	 *     (op+=And | (op+=And op+=And+))
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Satisfy returns Parametre
	 *     Parametre returns Parametre
	 *
	 * Constraint:
	 *     (numParam=EBigInteger (typesParam+=EString typesParam+=EString*)?)
	 */
	protected void sequence_Parametre(ISerializationContext context, Parametre semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Satisfy returns Return
	 *     Return returns Return
	 *
	 * Constraint:
	 *     returnType=EString
	 */
	protected void sequence_Return(ISerializationContext context, Return semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JavaRulePackage.Literals.RETURN__RETURN_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavaRulePackage.Literals.RETURN__RETURN_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReturnAccess().getReturnTypeEStringParserRuleCall_1_0(), semanticObject.getReturnType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RuleSet returns RuleSet
	 *
	 * Constraint:
	 *     (ProjectName=EString? rules+=Rule rules+=Rule*)
	 */
	protected void sequence_RuleSet(ISerializationContext context, RuleSet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns Rule
	 *
	 * Constraint:
	 *     (action=Action on=Testing)
	 */
	protected void sequence_Rule(ISerializationContext context, Rule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JavaRulePackage.Literals.RULE__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavaRulePackage.Literals.RULE__ACTION));
			if (transientValues.isValueTransient(semanticObject, JavaRulePackage.Literals.RULE__ON) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavaRulePackage.Literals.RULE__ON));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRuleAccess().getActionActionEnumRuleCall_0_0(), semanticObject.getAction());
		feeder.accept(grammarAccess.getRuleAccess().getOnTestingParserRuleCall_1_0(), semanticObject.getOn());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Testing returns Testing
	 *
	 * Constraint:
	 *     (no?='no'? quantifier=Quantifier element=Element satisfy=Or)
	 */
	protected void sequence_Testing(ISerializationContext context, Testing semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Satisfy returns Variable
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     ((position?='right position' initialize?='initialized'?) | (initialize?='initialized' position?='right position'?))
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}

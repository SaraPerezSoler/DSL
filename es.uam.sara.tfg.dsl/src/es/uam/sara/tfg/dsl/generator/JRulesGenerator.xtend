/*
 * generated by Xtext 2.10.0
 */
package es.uam.sara.tfg.dsl.generator

import javaRule.And
import javaRule.Attribute
import javaRule.Class
import javaRule.Enumeration
import javaRule.Interface
import javaRule.Method
import javaRule.Or
import javaRule.Package
import javaRule.Rule
import javaRule.RuleSet
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.core.resources.ResourcesPlugin
import org.eclipse.core.resources.IProject
import java.util.List
import java.util.ArrayList
import javaRule.Sentence
import javaRule.Variable
import javaRule.Element
import javaRule.PrimaryOp
import javaRule.PropertyLiteral
import javaRule.VariableSubtype

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class JRulesGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
//		fsa.generateFile('greetings.txt', 'People to greet: ' + 
//			resource.allContents
//				.filter(typeof(Greeting))
//				.map[name]
//				.join(', '))

		var sentences=resource.allContents.toIterable.filter(Sentence)
		
		fsa.generateFile("RuleFactory.java", RuleFactory(sentences.toList));
		
		var workspace = ResourcesPlugin.getWorkspace().getRoot();
		var ruleSet = resource.allContents.toIterable.filter(RuleSet).get(0)
		var projects = new ArrayList<IProject>();

		if (ruleSet.projectName.empty) {
			projects.addAll(workspace.projects);
		} else {
			for (name : ruleSet.projectName) {
				projects.add(workspace.getProject(name));
			}
		}
		fsa.generateFile("Main.java", main(projects));

	}


	def CharSequence main(List<IProject> projects) {

		'''
			import java.io.File;
			import java.io.FileWriter;
			import java.io.IOException;
			import java.io.PrintWriter;
			import java.util.List;
			import java.util.ArrayList;
			import es.uam.sara.tfg.ast.ReadFiles;
			import es.uam.sara.tfg.rule.Rule;
			import es.uam.sara.tfg.ast.Visitors;
				
				public class Main {
				
				 
				 public static void main(String[] args)throws IOException{
				 	
				 	List<Visitors> projects= new ArrayList<Visitors>();
					List<File> roots= new ArrayList<File>();
					
			 		«FOR p: projects»
			 			«var src= p.getFolder("src")»
			 			roots.add(new File("«src.location»"));
			 			projects.add(new Visitors("«p.name»"));
			 		«ENDFOR»

				 	for (int i=0; i <roots.size(); i++){
				 		File root=roots.get(i);
				 		Visitors visit=projects.get(i);
				 		ReadFiles.parseFiles(root, visit);
				 		RuleFactory rf= new RuleFactory(visit);
				 		rf.getRules();
				 		rf.writeLog();
				 	}
				 }
				}
		'''
	}

	def CharSequence RuleFactory(List<Sentence> sentences) {

		var i = 1;
		'''
			import java.io.FileWriter;
			import java.io.PrintWriter;
			import java.util.*;
			import es.uam.sara.tfg.rule.*;
			import es.uam.sara.tfg.rule.Rule.*;
			import es.uam.sara.tfg.properties.*;
			import es.uam.sara.tfg.properties.interfaces.*;
			import es.uam.sara.tfg.properties.classes.*;
			import es.uam.sara.tfg.properties.enumerations.*;
			import es.uam.sara.tfg.properties.methods.*;
			import es.uam.sara.tfg.properties.attributes.*;
			import es.uam.sara.tfg.properties.packages.*;
			import org.eclipse.jdt.core.dom.TypeDeclaration;
			import org.eclipse.jdt.core.dom.EnumDeclaration;
			import org.eclipse.jdt.core.dom.MethodDeclaration;
			import org.eclipse.jdt.core.dom.FieldDeclaration;
			import es.uam.sara.tfg.ast.Visitors;
			import es.uam.sara.tfg.properties.Properties;
			
			public class RuleFactory {
				
				private List <Rule<?>> rules=null;
				private Visitors visitors;
				
				public RuleFactory (Visitors vis){
					this.visitors=vis;
				}
				public List<Rule<?>> getRules(){
					if (rules!=null){
						return rules;
					}else{
						rules= new ArrayList<Rule<?>>();
						List<String> packages=visitors.getPackages();
						List<TypeDeclaration> classes=visitors.getClasses();
						List<TypeDeclaration> interfaces=visitors.getInterfaces();
						List<EnumDeclaration> enums=visitors.getEnumerations();
						List<MethodDeclaration> methods=visitors.getMethods();
						List<FieldDeclaration> attributes=visitors.getAttributes();
						
					//Crear
					«FOR Sentence s : sentences»
						«IF s instanceof Variable»
						«var v= s as Variable»
						«genetateVariable(v)»
						Sentences.allVariables.put("«v.name»", «v.name»);
						«ELSE»
						«var r= s as Rule»
						«IF r.eContainer instanceof RuleSet»
							«r.name="rule"+i»
							«genetateRule(r, ""+(i++))»
							rules.add(«r.name»);
						«ENDIF»
						«ENDIF»
					«ENDFOR»
					«generateDependences(sentences)»
					return rules;
					}
				}
				
				public void writeLog(){
					
						FileWriter fichero = null;
				 		PrintWriter pw = null;
				 		try{
							fichero = new FileWriter("outs/"+visitors.getProjectName+".txt");
							pw = new PrintWriter(fichero);
							
							for (Rule<?> r: rules){
								System.out.println(r.log());
								pw.println(r.log());
							}
			     } catch (Exception e) {
			          e.printStackTrace();
			      } finally {
			         try {
			          if (null != fichero)
			             fichero.close();
			         } catch (Exception e2) {
			            e2.printStackTrace();
			         }
			      }
									        
				}
			}
			
		'''
	}
	def CharSequence generateDependences(List<Sentence> s){'''
			«FOR Sentence v : s»
				«IF v.eContainer instanceof RuleSet»
					«FOR Variable in: v.in»
						«v.name».setIn(Sentences.allVariables.get("«in.name»").get());
					«ENDFOR»
					«var k=0»
					«IF v.from!=null»
						for («getType(v.from.element)» us«k»: «v.from.getName».get()){
							«v.name».setFrom(us«k».get«getType(v.element)»s());
							«v.name».setUsing("«v.from.getName»",us«k++»);
					«ENDIF»
						
						«FOR VariableSubtype us: v.using»
							«IF us.subtype==Element.NULL»
							for («getType(us.variable.element)» us«k»: «us.variable.name».get()){
								«v.name».setUsing("«us.variable.name»",us«k++»);
							«ELSE»
							for («getType(us.subtype)» us«k»: us«getK(v, us.variable.name)».get«getType(us.subtype)»s()){
								«v.name».setUsing("«us.variable.name»«getType(us.subtype)»",us«k++»);
							«ENDIF»
						«ENDFOR»
							«v.name».check();
						«FOR VariableSubtype us: v.using»
						}
						«ENDFOR»
					«IF v.from!=null»
						}
					«ENDIF»
				«ENDIF»
				
			«ENDFOR»'''
	}
	
	def int getK(Sentence s, String name) {
		var i=0;
		if (s.from!=null){
			if (s.from.name.equals(name)){
				return i;
			}
			i++;
		}
		var us= s.using;
		for(VariableSubtype vs: us){
			if (vs.variable.name.equals(name)){
				return i;
			}
			i++;
		}
		return -1;
	}

	def static String genetateVariable(Variable v) {
		'''
			«var name=v.name»
			//v: «v.toString»
			«var type=getType(v.element)»
			«var analize=getType(v.element).toLowerCase»
			«getOr(v.satisfy, name, v.element)»
			Varieble<«type»> «name»=new Varieble<«type»> ( "«v.element»",«analize», or«name»);	
		'''
	}

	def static String genetateRule(Rule r,
		String i) {
		'''
			//r«i»: «r.toString»
			«var type=getType(r.element)»
			«var analize=getType(r.element).toLowerCase»
			«getOr(r.filter, "Filter"+i, r.element)»
			«getOr(r.satisfy, i, r.element)»
			Rule<«type»> «r.name»=new Rule<«type»> («r.no», Quantifier.«r.quantifier.literal.toUpperCase»,«analize»,orFilter«i», or«i», "«r.element»");	
		'''
	}

	def static CharSequence getOr(Or or, String i, Element element) {
		'''
		«var type= getType(element)»
		«IF or!=null»
			Or<«type»> or«i»= new Or<«type»>();
			«var j=1»
			«FOR And a: or.op»
				«getAnd(a, i+j, element)»
				or«i».addAnd(and«i»«j++»);
				
			«ENDFOR»
		«ELSE»
			Or<«type»> or«i»=	null;
			
		«ENDIF»'''
	}

	def static CharSequence getAnd(And a, String i, Element element) {
		'''
			«var j=1»
			«var type= getType(element)»
			And<«type»> and«i» = new And<«type»>();
			«FOR PrimaryOp s : a.op»
				«IF s instanceof Or»
					«getOr(s , i+j,element)»
					and«i».addPropertie(or«i»«j++»);
				«ELSEIF s instanceof PropertyLiteral»
					«getSatisfy((s as PropertyLiteral),element, i+j)»
					and«i».addPropertie(p«i»«j++»);
				«ENDIF»
				
			«ENDFOR»
		'''
	}

	def static CharSequence getSatisfy(PropertyLiteral s, Element e, String sufix) {
		if (e == Element.PACKAGE) {
			return PackageSatisfy.getPropertie(s.property as Package, sufix);
		} else if (e == Element.INTERFACE) {
			return InterfaceSatisfy.getPropertie(s.property as Interface, sufix);
		} else if (e == Element.CLASS) {
			return ClassesSatisfy.getPropertie(s.property as Class, sufix);
		} else if (e == Element.ENUM) {
			return EnumSatisfy.getPropertie(s.property as Enumeration, sufix);
		} else if (e == Element.METHOD) {
			return MethodsSatisfy.getPropertie(s.property as Method, sufix);
		} else {
			return AttributesSatisfy.getPropertie(s.property as Attribute, sufix);
		}
	}

	def static String getType(Element e) {
		return e.literal.toLowerCase.toFirstUpper;
	}
}

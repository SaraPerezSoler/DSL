/*
 * generated by Xtext 2.10.0
 */
package es.uam.sara.tfg.dsl.validation

import org.eclipse.xtext.validation.Check
import javaRule.Rule
import javaRule.Or
import javaRule.And
import javaRule.Interface
import javaRule.Enumeration
import javaRule.Method
import javaRule.JavaRulePackage
import javaRule.NameOperator
import javaRule.JavaDoc
import javaRule.BlendModifiers
import javaRule.AccessModifier
import javaRule.Contains
import javaRule.Attribute
import javaRule.Language
import javaRule.RuleSet
import javaRule.Implements
import javaRule.Parameter
import javaRule.NameOperation
import org.eclipse.core.resources.ResourcesPlugin
import javaRule.Quantifier
import java.lang.annotation.ElementType
import javaRule.Element
import javaRule.Sentence
import javaRule.Variable
import javaRule.PrimaryOp
import javaRule.PropertyLiteral
import javaRule.StringVariable
import java.util.List
import javaRule.VariableSubtype

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class JRulesValidator extends AbstractJRulesValidator {

	public static val INVALID_SATISFY = 'invalidSatisfy'
	
	public static val INVALID_IN='invalidIn'

//	public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					JRulesPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
	@Check
	def checkProject(RuleSet rs) {
		if (!rs.projectName.isEmpty) {
			var workspace = ResourcesPlugin.getWorkspace().getRoot();
			for (name : rs.projectName) {
				if (name == "") {
					error("The project " + name + " is not into worksapce",
						JavaRulePackage.Literals.RULE_SET__PROJECT_NAME, "invalidProject")
				} else {
					var project = workspace.getProject(name)
					if (!project.exists) {
						error("The project " + name + " is not into worksapce",
							JavaRulePackage.Literals.RULE_SET__PROJECT_NAME, "invalidProject")
					}
				}
			}
		}
	}

	@Check
	def checkSatisfyExists(Rule r) {

		if (((r.eContainer instanceof RuleSet)) && (r.satisfy == null)) {
			error("\"Satisfy\" is required", JavaRulePackage.Literals.RULE__QUANTIFIER, "invalidRule")
		} else if ((r.quantifier == Quantifier.ALL) && (r.satisfy == null)) {
			error("\"Satisfy\" is required with quantifier all", JavaRulePackage.Literals.RULE__QUANTIFIER,
				"invalidRule")
		}
		if ((r.satisfy == null) && (r.filter != null)) {
			error("\"Satisfy\" is required after clause \"which\"", JavaRulePackage.Literals.RULE__FILTER,
				"invalidRule")
		}
	}

	@Check
	def checkTypes(Sentence r) {
		if (r instanceof Rule) {
			if (comprobarPropiedades(r.filter, r.element) == false) {
				error("This filter is not valid for " + r.element.literal.toLowerCase,
					JavaRulePackage.Literals.RULE__FILTER, INVALID_SATISFY);
			}
		}
		for (Variable in : r.in) {
			if (in.element != r.element) {
				error(
					"The clause 'in' must be the same type than the sentences",
					JavaRulePackage.Literals.SENTENCE__IN,
					INVALID_SATISFY
				)
			}
		}
		if (r.from != null) {
			if (r.from.element == Element.ATTRIBUTE || r.from.element == Element.METHOD) {
				error(
					"The clause 'from' can't be attributes or methods",
					JavaRulePackage.Literals.SENTENCE__FROM,
					INVALID_SATISFY
				)
			}
		}

		if (comprobarPropiedades(r.satisfy, r.element) == false) {
			error(
				"This property is not valid for " + r.element.literal.toLowerCase,
				JavaRulePackage.Literals.SENTENCE__SATISFY,
				INVALID_SATISFY
			)
		}
	}

	def boolean comprobarPropiedades(Or or, Element e) {
		var ret = true;
		if (or==null){
			return true;
		}
		for (And a : or.op) {
			for (PrimaryOp s : a.op) {
				if (s instanceof PropertyLiteral) {
					ret = ret && comprobarSatisfy(e, s.property)
				} else {
					ret = ret && comprobarPropiedades(s as Or, e);
				}
			}
		}
		return ret;
	}

	def comprobarSatisfy(Element e, javaRule.Property s) {
		if ((e == Element.PACKAGE) && (s instanceof javaRule.Package)) {
			return true;
		} else if ((e == Element.INTERFACE) && (s instanceof Interface)) {
			return true;
		} else if ((e == Element.CLASS) && (s instanceof javaRule.Class)) {
			return true;
		} else if ((e == Element.ENUM) && (s instanceof Enumeration)) {
			return true;
		} else if ((e == Element.METHOD) && (s instanceof Method)) {
			return true;
		} else if ((e == Element.ATTRIBUTE) && (s instanceof Attribute)) {
			return true;
		} else {
			return false;
		}

	}
	
	@Check
	def checkStringVariableUsing(Sentence s){
		if (s.eContainer instanceof RuleSet){
			var sv=s.eAllContents.toIterable.filter(StringVariable).toList
			println
			for (StringVariable svs: sv){
				var name=svs.variable.variable.name
				if (svs.variable.subtype!=Element.NULL){
					name+="."+svs.variable.subtype;
				}
				if (!s.using.contain(svs.variable) && !s.from.equals(svs.variable.variable)){
					error(
					"The variable "+name+"must be declared in 'using' or 'from' clause  ",
					JavaRulePackage.Literals.SENTENCE__SATISFY
					)
				}
				println(name)
			}
			println(sv)
		}
	}
	
	def contain (List<VariableSubtype> using, VariableSubtype vs){
		for (VariableSubtype uvs: using){
			if (uvs.subtype== vs.subtype && uvs.variable.equals(vs.variable)){
				return true;
			}
		}
		return false;
	}
		@Check
	def checkUsingOnlyRuleSetSentence(Sentence s){
		if (!(s.eContainer instanceof RuleSet) && !s.using.isEmpty){
			error(
				"The 'using' clause must be in the first sentence",
				JavaRulePackage.Literals.SENTENCE__USING,
				INVALID_IN
			)
		}
	}
	
//
//	@Check
//	def checkNameLanguage(NameOperation n) {
//		if (n.operator == NameOperator.LIKE && n.language == Language.EMPTY) {
//			error(
//				"Language must be define for Like operator",
//				JavaRulePackage.Literals.NAME_OPERATION__OPERATOR,
//				"invalidLanguage"
//			)
//		}
//		if (n.operator != NameOperator.LIKE && n.language != Language.EMPTY) {
//			error(
//				"Language is only for Like operator",
//				JavaRulePackage.Literals.NAME_OPERATION__LANGUAGE,
//				"invalidLanguage"
//			)
//		}
//	}
//
//	@Check
//	def checkJavaDoc(JavaDoc jd) {
//		var rule = getRule(jd);
//		if (rule.element != ElementJava.METHOD && jd.parameter) {
//			warning("The tag @parameter is used for methods", JavaRulePackage.Literals.JAVA_DOC__PARAMETER,
//				'inadvisableJavaDoc')
//		}
//		if (rule.element != ElementJava.METHOD && jd.^return) {
//			warning("The tag @return is used for methods", JavaRulePackage.Literals.JAVA_DOC__RETURN,
//				'inadvisableJavaDoc')
//		}
//		if (rule.element != ElementJava.METHOD && jd.throws) {
//			warning("The tag @throws is used for methods", JavaRulePackage.Literals.JAVA_DOC__THROWS,
//				'inadvisableJavaDoc')
//		}
//	}
//
//	def getRule(JavaDoc jd) {
//		var aux1 = jd.eContainer.eContainer.eContainer;
//		var aux2 = jd.eContainer.eContainer.eContainer.eContainer;
//		if (aux1 instanceof Rule) {
//			var rule = aux1 as Rule
//			return rule;
//		} else if (aux2 instanceof Rule) {
//			var rule = aux2 as Rule
//			return rule;
//		}
//	}
//
//	def getRule(BlendModifiers b) {
//		var aux1 = b.eContainer.eContainer.eContainer.eContainer;
//		var aux2 = b.eContainer.eContainer.eContainer.eContainer.eContainer;
//		if (aux1 instanceof Rule) {
//			var rule = aux1 as Rule
//			// println("Dentro de Satisfy "+ rule.quantifier+" "+rule.element)
//			return rule;
//		} else if (aux2 instanceof Rule) {
//			var rule = aux2 as Rule
//			// println("Dentro de filter "+ rule.quantifier+" "+rule.element)
//			return rule;
//		}
//	}
//
//	@Check
//	def checkModifiers(BlendModifiers b) {
//
//		var r = getRule(b);
//		
//		if (accessPrivateProtecte(b)) {
//			if (r.element == ElementJava.CLASS || r.element == ElementJava.INTERFACE || r.element == ElementJava.ENUM) {
//				warning("The private and protected modifiers are for classes, interfaces and enumeration internal",
//					JavaRulePackage.Literals.BLEND_MODIFIERS__ACCESS, 'inadvisableModifier')
//			}
//		}
//		if (b.abstract) {
//			if (r.element == ElementJava.INTERFACE) {
//				warning("The interfaces are implicitly abstract, its not necessary add the modifier",
//					JavaRulePackage.Literals.BLEND_MODIFIERS__ABSTRACT, 'inadvisableModifier')
//			} else if (r.element != ElementJava.CLASS && r.element != ElementJava.METHOD) {
//				error("Abstract is for methods and class", JavaRulePackage.Literals.BLEND_MODIFIERS__ABSTRACT,
//					'invalidModifier')
//			} else if (b.final) {
//				error("Methods and Class can't be abstract and final simultaneously",
//					JavaRulePackage.Literals.BLEND_MODIFIERS__ABSTRACT, 'invalidModifier')
//			}
//		}
//		if (b.^default){
//			if (r.element!=ElementJava.METHOD){
//				error("Only the methods can be default", JavaRulePackage.Literals.BLEND_MODIFIERS__DEFAULT, 'invalidModifier')
//			}
//			if (r.eContainer instanceof RuleSet){
//				///////////////////////////////////////////////////////////
//			}
//		}
//
//		if (b.final) {
//			if (r.element == ElementJava.INTERFACE || r.element == ElementJava.ENUM) {
//				error("Final is for methods, class and attributes", JavaRulePackage.Literals.BLEND_MODIFIERS__FINAL,
//					'invalidModifier')
//			}
//		}
//
//		if (b.static) {
//			if (r.element == ElementJava.CLASS || r.element == ElementJava.INTERFACE || r.element == ElementJava.ENUM) {
//				warning("Static is for classes, interfaces and enumeration internal",
//					JavaRulePackage.Literals.BLEND_MODIFIERS__ACCESS, 'inadvisableModifier')
//			}
//		}
//		if (b.synchronized && r.element != ElementJava.METHOD) {
//			error("Synchronized is for methods", JavaRulePackage.Literals.BLEND_MODIFIERS__SYNCHRONIZED,
//				'invalidModifier')
//		}
//
//	}
//
//	def accessPrivateProtecte(BlendModifiers b) {
//		if (b.access == AccessModifier.PRIVATE || b.access == AccessModifier.PROTECTED) {
//			return true;
//		}
//		return false;
//	}
//
//	@Check
//	def checkContains(Contains c) {
//		var r = getRule(c);
//		if (r.element == ElementJava.PACKAGE) {
//			if (c.which.element == ElementJava.METHOD || c.which.element == ElementJava.ATTRIBUTE ||
//				c.which.element == ElementJava.PACKAGE) {
//				error("Package contains Class, Interfaces or Enumerations", JavaRulePackage.Literals.CONTAINS__WHICH,
//					"invalidContains")
//			}
//		}
//	}
//
//	def getRule(Contains c) {
//		var aux1 = c.eContainer.eContainer.eContainer;
//		var aux2 = c.eContainer.eContainer.eContainer.eContainer;
//		if (aux1 instanceof Rule) {
//			var rule = aux1 as Rule
//			// println("Dentro de Satisfy "+ rule.quantifier+" "+rule.element)
//			return rule;
//		} else if (aux2 instanceof Rule) {
//			var rule = aux2 as Rule
//			// println("Dentro de filter "+ rule.quantifier+" "+rule.element)
//			return rule;
//		}
//	}
//
//	@Check
//	def checkImplements(Implements i) {
//		if (i.minInterface < 0) {
//			error("The minimum of interfaces must be greater than 0",
//				JavaRulePackage.Literals.IMPLEMENTS__MIN_INTERFACE, 'invalidMin')
//		}
//		if (i.maxInterface < 0) {
//			error("The maximum of interfaces must be greater than 0",
//				JavaRulePackage.Literals.IMPLEMENTS__MAX_INTERFACE, 'invalidMin')
//		}
//
//		if (i.minInterface > i.maxInterface) {
//			error("The minimum of interfaces can't be greater than the maximum",
//				JavaRulePackage.Literals.IMPLEMENTS__MIN_INTERFACE, 'invalidMin')
//		}
//	}
//
//	@Check
//	def checkParameters(Parameter p) {
//		if (p.typesParam.length != 0) {
//			if (p.typesParam.length != p.numParam) {
//				error("The number of parameters should be equal to the number of types",
//					JavaRulePackage.Literals.PARAMETER__NUM_PARAM, 'invalidMin')
//			}
//		}
//	}
}

/**
 * generated by Xtext 2.10.0
 */
package es.uam.sara.tfg.dsl.validation;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import es.uam.sara.tfg.dsl.validation.AbstractJRulesValidator;
import java.util.List;
import javaRule.AccessModifier;
import javaRule.And;
import javaRule.Attribute;
import javaRule.BlendModifiers;
import javaRule.Contains;
import javaRule.Element;
import javaRule.Enumeration;
import javaRule.File;
import javaRule.Interface;
import javaRule.JavaDoc;
import javaRule.JavaRulePackage;
import javaRule.Language;
import javaRule.Method;
import javaRule.Modifiers;
import javaRule.NameOperation;
import javaRule.NameOperator;
import javaRule.Or;
import javaRule.Parameter;
import javaRule.PrimaryOp;
import javaRule.Property;
import javaRule.PropertyLiteral;
import javaRule.Quantifier;
import javaRule.RangoNames;
import javaRule.Rule;
import javaRule.RuleSet;
import javaRule.Sentence;
import javaRule.StringProperty;
import javaRule.StringVariable;
import javaRule.Tamanio;
import javaRule.TypeProperty;
import javaRule.Variable;
import javaRule.VariableSubtype;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IWorkspace;
import org.eclipse.core.resources.IWorkspaceRoot;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.StringExtensions;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class JRulesValidator extends AbstractJRulesValidator {
  public final static String INVALID_SATISFY = "invalidSatisfy";
  
  public final static String INVALID_IN = "invalidIn";
  
  @Check
  public void checkProject(final RuleSet rs) {
    EList<String> _projectName = rs.getProjectName();
    boolean _isEmpty = _projectName.isEmpty();
    boolean _not = (!_isEmpty);
    if (_not) {
      IWorkspace _workspace = ResourcesPlugin.getWorkspace();
      IWorkspaceRoot workspace = _workspace.getRoot();
      EList<String> _projectName_1 = rs.getProjectName();
      for (final String name : _projectName_1) {
        boolean _equals = Objects.equal(name, "");
        if (_equals) {
          this.error((("The project " + name) + " is not into worksapce"), 
            JavaRulePackage.Literals.RULE_SET__PROJECT_NAME, "invalidProject");
        } else {
          IProject project = workspace.getProject(name);
          boolean _exists = project.exists();
          boolean _not_1 = (!_exists);
          if (_not_1) {
            this.error((("The project " + name) + " is not into worksapce"), 
              JavaRulePackage.Literals.RULE_SET__PROJECT_NAME, "invalidProject");
          }
        }
      }
    }
  }
  
  @Check
  public void checkSatisfyExists(final Rule r) {
    if (((r.eContainer() instanceof RuleSet) && Objects.equal(r.getSatisfy(), null))) {
      this.error("\"Satisfy\" is required", JavaRulePackage.Literals.RULE__QUANTIFIER, "invalidRule");
    } else {
      if ((Objects.equal(r.getQuantifier(), Quantifier.ALL) && Objects.equal(r.getSatisfy(), null))) {
        this.error("\"Satisfy\" is required with quantifier all", JavaRulePackage.Literals.RULE__QUANTIFIER, 
          "invalidRule");
      }
    }
    if ((Objects.equal(r.getSatisfy(), null) && (!Objects.equal(r.getFilter(), null)))) {
      this.error("\"Satisfy\" is required after clause \"which\"", JavaRulePackage.Literals.RULE__FILTER, 
        "invalidRule");
    }
  }
  
  @Check
  public void checkTypes(final Sentence r) {
    if ((r instanceof Rule)) {
      Or _filter = ((Rule)r).getFilter();
      Element _element = ((Rule)r).getElement();
      boolean _comprobarPropiedades = this.comprobarPropiedades(_filter, _element);
      boolean _equals = (_comprobarPropiedades == false);
      if (_equals) {
        Element _element_1 = ((Rule)r).getElement();
        String _literal = _element_1.getLiteral();
        String _lowerCase = _literal.toLowerCase();
        String _plus = ("This filter is not valid for " + _lowerCase);
        this.error(_plus, 
          JavaRulePackage.Literals.RULE__FILTER, JRulesValidator.INVALID_SATISFY);
      }
    }
    EList<Variable> _in = r.getIn();
    for (final Variable in : _in) {
      Element _element_2 = in.getElement();
      Element _element_3 = r.getElement();
      boolean _notEquals = (!Objects.equal(_element_2, _element_3));
      if (_notEquals) {
        this.error(
          "The clause \'in\' must be the same type than the sentences", 
          JavaRulePackage.Literals.SENTENCE__IN, 
          JRulesValidator.INVALID_SATISFY);
      }
    }
    Variable _from = r.getFrom();
    boolean _notEquals_1 = (!Objects.equal(_from, null));
    if (_notEquals_1) {
      if ((Objects.equal(r.getFrom().getElement(), Element.ATTRIBUTE) || Objects.equal(r.getFrom().getElement(), Element.METHOD))) {
        this.error(
          "The clause \'from\' can\'t be attributes or methods", 
          JavaRulePackage.Literals.SENTENCE__FROM, 
          JRulesValidator.INVALID_SATISFY);
      }
    }
    Or _satisfy = r.getSatisfy();
    Element _element_4 = r.getElement();
    boolean _comprobarPropiedades_1 = this.comprobarPropiedades(_satisfy, _element_4);
    boolean _equals_1 = (_comprobarPropiedades_1 == false);
    if (_equals_1) {
      Element _element_5 = r.getElement();
      String _literal_1 = _element_5.getLiteral();
      String _lowerCase_1 = _literal_1.toLowerCase();
      String _plus_1 = ("This property is not valid for " + _lowerCase_1);
      this.error(_plus_1, 
        JavaRulePackage.Literals.SENTENCE__SATISFY, 
        JRulesValidator.INVALID_SATISFY);
    }
  }
  
  public boolean comprobarPropiedades(final Or or, final Element e) {
    boolean ret = true;
    boolean _equals = Objects.equal(or, null);
    if (_equals) {
      return true;
    }
    EList<And> _op = or.getOp();
    for (final And a : _op) {
      EList<PrimaryOp> _op_1 = a.getOp();
      for (final PrimaryOp s : _op_1) {
        if ((s instanceof PropertyLiteral)) {
          ret = (ret && this.comprobarSatisfy(e, ((PropertyLiteral)s).getProperty()));
        } else {
          ret = (ret && this.comprobarPropiedades(((Or) s), e));
        }
      }
    }
    return ret;
  }
  
  public boolean comprobarSatisfy(final Element e, final Property s) {
    if ((Objects.equal(e, Element.PACKAGE) && (s instanceof javaRule.Package))) {
      return true;
    } else {
      if ((Objects.equal(e, Element.INTERFACE) && (s instanceof Interface))) {
        return true;
      } else {
        if ((Objects.equal(e, Element.CLASS) && (s instanceof javaRule.Class))) {
          return true;
        } else {
          if ((Objects.equal(e, Element.ENUMERATION) && (s instanceof Enumeration))) {
            return true;
          } else {
            if ((Objects.equal(e, Element.METHOD) && (s instanceof Method))) {
              return true;
            } else {
              if ((Objects.equal(e, Element.ATTRIBUTE) && (s instanceof Attribute))) {
                return true;
              } else {
                if ((Objects.equal(e, Element.FILE) && (s instanceof File))) {
                  return true;
                } else {
                  return false;
                }
              }
            }
          }
        }
      }
    }
  }
  
  @Check
  public void checkStringVariableUsing(final Sentence s) {
    EObject _eContainer = s.eContainer();
    if ((_eContainer instanceof RuleSet)) {
      TreeIterator<EObject> _eAllContents = s.eAllContents();
      Iterable<EObject> _iterable = IteratorExtensions.<EObject>toIterable(_eAllContents);
      Iterable<StringVariable> _filter = Iterables.<StringVariable>filter(_iterable, StringVariable.class);
      List<StringVariable> sv = IterableExtensions.<StringVariable>toList(_filter);
      for (final StringVariable svs : sv) {
        {
          VariableSubtype _variable = svs.getVariable();
          Variable _variable_1 = _variable.getVariable();
          String name = _variable_1.getName();
          VariableSubtype _variable_2 = svs.getVariable();
          Element _subtype = _variable_2.getSubtype();
          boolean _notEquals = (!Objects.equal(_subtype, Element.NULL));
          if (_notEquals) {
            String _name = name;
            VariableSubtype _variable_3 = svs.getVariable();
            Element _subtype_1 = _variable_3.getSubtype();
            String _plus = ("." + _subtype_1);
            name = (_name + _plus);
            EList<VariableSubtype> _using = s.getUsing();
            VariableSubtype _variable_4 = svs.getVariable();
            boolean _contain = this.contain(_using, _variable_4);
            boolean _not = (!_contain);
            if (_not) {
              this.error(
                (("The variable " + name) + "must be declared in \'using\' clause  "), 
                JavaRulePackage.Literals.SENTENCE__SATISFY);
            }
          } else {
            EList<VariableSubtype> _using_1 = s.getUsing();
            VariableSubtype _variable_5 = svs.getVariable();
            boolean _contain_1 = this.contain(_using_1, _variable_5);
            boolean _not_1 = (!_contain_1);
            if (_not_1) {
              Variable _from = s.getFrom();
              boolean _equals = Objects.equal(_from, null);
              if (_equals) {
                this.error(
                  (("The variable " + name) + "must be declared in \'using\' or \'from\' clause  "), 
                  JavaRulePackage.Literals.SENTENCE__SATISFY);
              }
              Variable _from_1 = s.getFrom();
              VariableSubtype _variable_6 = svs.getVariable();
              Variable _variable_7 = _variable_6.getVariable();
              boolean _equals_1 = _from_1.equals(_variable_7);
              boolean _not_2 = (!_equals_1);
              if (_not_2) {
                this.error(
                  (("The variable " + name) + " must be declared in \'using\' or \'from\' clause  "), 
                  JavaRulePackage.Literals.SENTENCE__SATISFY);
              }
            }
          }
        }
      }
    }
  }
  
  public boolean contain(final List<VariableSubtype> using, final VariableSubtype vs) {
    for (final VariableSubtype uvs : using) {
      if ((Objects.equal(uvs.getSubtype(), vs.getSubtype()) && uvs.getVariable().equals(vs.getVariable()))) {
        return true;
      }
    }
    return false;
  }
  
  @Check
  public void checkUsingOnlyRuleSetSentence(final Sentence s) {
    if (((!(s.eContainer() instanceof RuleSet)) && (!s.getUsing().isEmpty()))) {
      this.error(
        "The \'using\' clause must be in the first sentence", 
        JavaRulePackage.Literals.SENTENCE__USING, 
        JRulesValidator.INVALID_IN);
    }
  }
  
  @Check
  public void checkNameLanguage(final NameOperation n) {
    if ((Objects.equal(n.getOperator(), NameOperator.LIKE) && Objects.equal(n.getLanguage(), Language.EMPTY))) {
      this.error(
        "Language must be define for Like operator", 
        JavaRulePackage.Literals.NAME_OPERATION__OPERATOR, 
        "invalidLanguage");
    }
    if (((!Objects.equal(n.getOperator(), NameOperator.LIKE)) && (!Objects.equal(n.getLanguage(), Language.EMPTY)))) {
      this.error(
        "Language is only for Like operator", 
        JavaRulePackage.Literals.NAME_OPERATION__LANGUAGE, 
        "invalidLanguage");
    }
  }
  
  @Check
  public void checkJavaDoc(final JavaDoc jd) {
    Sentence s = this.getSentece(jd);
    if (((!Objects.equal(s.getElement(), Element.METHOD)) && jd.isParameter())) {
      this.warning("The tag @parameter is used for methods", JavaRulePackage.Literals.JAVA_DOC__PARAMETER, 
        "inadvisableJavaDoc");
    }
    if (((!Objects.equal(s.getElement(), Element.METHOD)) && jd.isReturn())) {
      this.warning("The tag @return is used for methods", JavaRulePackage.Literals.JAVA_DOC__RETURN, 
        "inadvisableJavaDoc");
    }
    if (((!Objects.equal(s.getElement(), Element.METHOD)) && jd.isThrows())) {
      this.warning("The tag @throws is used for methods", JavaRulePackage.Literals.JAVA_DOC__THROWS, 
        "inadvisableJavaDoc");
    }
  }
  
  public Sentence getSentece(final Property jd) {
    EObject conteiner = jd.eContainer();
    while ((!(conteiner instanceof Sentence))) {
      EObject _eContainer = conteiner.eContainer();
      conteiner = _eContainer;
    }
    return ((Sentence) conteiner);
  }
  
  @Check
  public void checkSubClassOfClass(final VariableSubtype vs) {
    if ((Objects.equal(vs.getVariable().getElement(), Element.ATTRIBUTE) && (!Objects.equal(vs.getSubtype(), Element.NULL)))) {
      Element _subtype = vs.getSubtype();
      String _string = _subtype.toString();
      String _firstUpper = StringExtensions.toFirstUpper(_string);
      String _plus = ("Attributes don\'t have " + _firstUpper);
      this.error(_plus, 
        JavaRulePackage.Literals.VARIABLE_SUBTYPE__SUBTYPE);
    }
    if ((Objects.equal(vs.getVariable().getElement(), Element.METHOD) && (!Objects.equal(vs.getSubtype(), Element.NULL)))) {
      Element _subtype_1 = vs.getSubtype();
      String _string_1 = _subtype_1.toString();
      String _firstUpper_1 = StringExtensions.toFirstUpper(_string_1);
      String _plus_1 = ("Methods don\'t have " + _firstUpper_1);
      this.error(_plus_1, 
        JavaRulePackage.Literals.VARIABLE_SUBTYPE__SUBTYPE);
    }
    if ((Objects.equal(vs.getSubtype(), Element.FILE) || Objects.equal(vs.getSubtype(), Element.PACKAGE))) {
      Variable _variable = vs.getVariable();
      Element _element = _variable.getElement();
      String _string_2 = _element.toString();
      String _firstUpper_2 = StringExtensions.toFirstUpper(_string_2);
      String _plus_2 = (_firstUpper_2 + " don\'t have ");
      Element _subtype_2 = vs.getSubtype();
      String _string_3 = _subtype_2.toString();
      String _firstUpper_3 = StringExtensions.toFirstUpper(_string_3);
      String _plus_3 = (_plus_2 + _firstUpper_3);
      this.error(_plus_3, 
        JavaRulePackage.Literals.VARIABLE_SUBTYPE__SUBTYPE);
    }
  }
  
  @Check
  public void checkModifiers(final BlendModifiers b) {
    EObject _eContainer = b.eContainer();
    Sentence r = this.getSentece(((Modifiers) _eContainer));
    boolean _accessPrivateProtecte = this.accessPrivateProtecte(b);
    if (_accessPrivateProtecte) {
      if (((Objects.equal(r.getElement(), Element.CLASS) || Objects.equal(r.getElement(), Element.INTERFACE)) || Objects.equal(r.getElement(), Element.ENUMERATION))) {
        this.warning("The private and protected modifiers are for classes, interfaces and enumeration internal", 
          JavaRulePackage.Literals.BLEND_MODIFIERS__ACCESS, "inadvisableModifier");
      }
    }
    boolean _isAbstract = b.isAbstract();
    if (_isAbstract) {
      Element _element = r.getElement();
      boolean _equals = Objects.equal(_element, Element.INTERFACE);
      if (_equals) {
        this.warning("The interfaces are implicitly abstract, its not necessary add the modifier", 
          JavaRulePackage.Literals.BLEND_MODIFIERS__ABSTRACT, "inadvisableModifier");
      } else {
        if (((!Objects.equal(r.getElement(), Element.CLASS)) && (!Objects.equal(r.getElement(), Element.METHOD)))) {
          this.error("Abstract is for methods and class", JavaRulePackage.Literals.BLEND_MODIFIERS__ABSTRACT, 
            "invalidModifier");
        } else {
          boolean _isFinal = b.isFinal();
          if (_isFinal) {
            this.error("Methods and Class can\'t be abstract and final simultaneously", 
              JavaRulePackage.Literals.BLEND_MODIFIERS__ABSTRACT, "invalidModifier");
          }
        }
      }
    }
    boolean _isDefault = b.isDefault();
    if (_isDefault) {
      Element _element_1 = r.getElement();
      boolean _notEquals = (!Objects.equal(_element_1, Element.METHOD));
      if (_notEquals) {
        this.error("Only the methods can be default", JavaRulePackage.Literals.BLEND_MODIFIERS__DEFAULT, 
          "invalidModifier");
      }
      EObject sente = this.getSentenceOrRuleSet(r);
      if ((sente instanceof Sentence)) {
        Element _element_2 = ((Sentence)sente).getElement();
        boolean _notEquals_1 = (!Objects.equal(_element_2, Element.INTERFACE));
        if (_notEquals_1) {
          this.error("Only the interface have default methods", JavaRulePackage.Literals.BLEND_MODIFIERS__DEFAULT, 
            "invalidModifier");
        }
      }
    }
    boolean _isFinal_1 = b.isFinal();
    if (_isFinal_1) {
      if ((Objects.equal(r.getElement(), Element.INTERFACE) || Objects.equal(r.getElement(), Element.ENUMERATION))) {
        this.error("Final is for methods, class and attributes", JavaRulePackage.Literals.BLEND_MODIFIERS__FINAL, 
          "invalidModifier");
      }
    }
    boolean _isStatic = b.isStatic();
    if (_isStatic) {
      if (((Objects.equal(r.getElement(), Element.CLASS) || Objects.equal(r.getElement(), Element.INTERFACE)) || Objects.equal(r.getElement(), Element.ENUMERATION))) {
        this.warning("Static is for classes, interfaces and enumeration internal", 
          JavaRulePackage.Literals.BLEND_MODIFIERS__ACCESS, "inadvisableModifier");
      }
    }
    if ((b.isSynchronized() && (!Objects.equal(r.getElement(), Element.METHOD)))) {
      this.error("Synchronized is for methods", JavaRulePackage.Literals.BLEND_MODIFIERS__SYNCHRONIZED, 
        "invalidModifier");
    }
  }
  
  public EObject getSentenceOrRuleSet(final Sentence s) {
    EObject container = s.eContainer();
    boolean flag = true;
    while (flag) {
      if ((container instanceof Sentence)) {
        flag = false;
      } else {
        if ((container instanceof RuleSet)) {
          flag = false;
        } else {
          EObject _eContainer = container.eContainer();
          container = _eContainer;
        }
      }
    }
    return container;
  }
  
  public boolean accessPrivateProtecte(final BlendModifiers b) {
    if ((Objects.equal(b.getAccess(), AccessModifier.PRIVATE) || Objects.equal(b.getAccess(), AccessModifier.PROTECTED))) {
      return true;
    }
    return false;
  }
  
  @Check
  public void checkUsing(final Sentence s) {
    EList<VariableSubtype> using = s.getUsing();
    for (final VariableSubtype us : using) {
      Element _subtype = us.getSubtype();
      boolean _notEquals = (!Objects.equal(_subtype, Element.NULL));
      if (_notEquals) {
        if (((this.checkExist(us, using) == false) && (this.checkExist(us, s.getFrom()) == false))) {
          Variable _variable = us.getVariable();
          String _name = _variable.getName();
          String _plus = ("The variable " + _name);
          String _plus_1 = (_plus + " must be declared in using clause before ");
          Variable _variable_1 = us.getVariable();
          String _name_1 = _variable_1.getName();
          String _plus_2 = (_plus_1 + _name_1);
          String _plus_3 = (_plus_2 + 
            ".");
          Element _subtype_1 = us.getSubtype();
          String _string = _subtype_1.toString();
          String _firstUpper = StringExtensions.toFirstUpper(_string);
          String _plus_4 = (_plus_3 + _firstUpper);
          this.error(_plus_4, JavaRulePackage.Literals.SENTENCE__USING, 
            "invalidModifier");
        }
      }
    }
  }
  
  public boolean checkExist(final VariableSubtype us, final Variable from) {
    boolean _equals = Objects.equal(from, null);
    if (_equals) {
      return false;
    }
    Variable _variable = us.getVariable();
    boolean _equals_1 = from.equals(_variable);
    if (_equals_1) {
      return true;
    }
    return false;
  }
  
  public boolean checkExist(final VariableSubtype us, final List<VariableSubtype> using) {
    int index = using.indexOf(us);
    for (int i = 0; (i < index); i++) {
      if ((using.get(i).getVariable().equals(us.getVariable()) && (!using.get(i).equals(us)))) {
        return true;
      }
    }
    return false;
  }
  
  @Check
  public void variableNameUnique(final Variable v) {
    RuleSet ruleSet = this.getRuleSet(v);
    TreeIterator<EObject> _eAllContents = ruleSet.eAllContents();
    Iterable<EObject> _iterable = IteratorExtensions.<EObject>toIterable(_eAllContents);
    Iterable<Variable> _filter = Iterables.<Variable>filter(_iterable, Variable.class);
    List<Variable> variables = IterableExtensions.<Variable>toList(_filter);
    for (final Variable v2 : variables) {
      if (((!v.equals(v2)) && v.getName().equals(v2.getName()))) {
        String _name = v.getName();
        String _plus = ("The name " + _name);
        String _plus_1 = (_plus + " must be unique");
        this.error(_plus_1, JavaRulePackage.Literals.SENTENCE__NAME, 
          "invalidModifier");
      }
    }
  }
  
  @Check
  public void checkContains(final Contains c) {
    Rule r = c.getRule();
    if ((Objects.equal(r.getElement(), Element.PACKAGE) || Objects.equal(r.getElement(), Element.FILE))) {
      Element _element = r.getElement();
      String _string = _element.toString();
      String _firstUpper = StringExtensions.toFirstUpper(_string);
      String _plus = ("This element don\'t have " + _firstUpper);
      this.error(_plus, 
        JavaRulePackage.Literals.CONTAINS__RULE, "invalidContains");
    }
  }
  
  @Check
  public void checkImplements(final RangoNames i) {
    int _min = i.getMin();
    boolean _lessThan = (_min < 0);
    if (_lessThan) {
      this.error("The minimum must be greater than 0", JavaRulePackage.Literals.RANGO_NAMES__MIN, "invalidMin");
    }
    int _max = i.getMax();
    boolean _lessThan_1 = (_max < 0);
    if (_lessThan_1) {
      this.error("The maximum must be greater than 0", JavaRulePackage.Literals.RANGO_NAMES__MAX, "invalidMin");
    }
    int _min_1 = i.getMin();
    int _max_1 = i.getMax();
    boolean _greaterThan = (_min_1 > _max_1);
    if (_greaterThan) {
      this.error("The minimum can\'t be greater than the maximum", JavaRulePackage.Literals.RANGO_NAMES__MAX, 
        "invalidMin");
    }
    EList<StringProperty> _types = i.getTypes();
    int _size = _types.size();
    int _max_2 = i.getMax();
    boolean _greaterThan_1 = (_size > _max_2);
    if (_greaterThan_1) {
      this.error("The number of types can\'t be greater than the maximum", 
        JavaRulePackage.Literals.RANGO_NAMES__MAX, "invalidMin");
    }
  }
  
  @Check
  public void checkParameters(final Parameter p) {
    int _exact = p.getExact();
    boolean _equals = (_exact == (-2147483647));
    if (_equals) {
      int _min = p.getMin();
      boolean _lessThan = (_min < 0);
      if (_lessThan) {
        this.error("The minimum must be greater than 0", JavaRulePackage.Literals.PARAMETER__MIN, "invalidMin");
      }
      int _max = p.getMax();
      boolean _lessThan_1 = (_max < 0);
      if (_lessThan_1) {
        this.error("The maximum must be greater than 0", JavaRulePackage.Literals.PARAMETER__MIN, "invalidMin");
      }
      int _min_1 = p.getMin();
      int _max_1 = p.getMax();
      boolean _greaterThan = (_min_1 > _max_1);
      if (_greaterThan) {
        this.error("The minimum can\'t be greater than the maximum", JavaRulePackage.Literals.PARAMETER__MIN, 
          "invalidMin");
      }
      EList<TypeProperty> _types = p.getTypes();
      int _size = _types.size();
      int _max_2 = p.getMax();
      boolean _greaterThan_1 = (_size > _max_2);
      if (_greaterThan_1) {
        this.error("The number of types can\'t be greater than the maximum", 
          JavaRulePackage.Literals.PARAMETER__MAX, "invalidMin");
      }
    } else {
      EList<TypeProperty> _types_1 = p.getTypes();
      int _size_1 = _types_1.size();
      int _exact_1 = p.getExact();
      boolean _greaterThan_2 = (_size_1 > _exact_1);
      if (_greaterThan_2) {
        this.error("The number of types can\'t be greater than the maximum", 
          JavaRulePackage.Literals.PARAMETER__EXACT, "invalidMin");
      }
    }
  }
  
  @Check
  public void checkTamanio(final Tamanio t) {
    int _exact = t.getExact();
    boolean _equals = (_exact == (-2147483647));
    if (_equals) {
      int _min = t.getMin();
      boolean _lessThan = (_min < 0);
      if (_lessThan) {
        this.error("The minimum must be greater than 0", JavaRulePackage.Literals.RANGO_NAMES__MIN, "invalidMin");
      }
      int _max = t.getMax();
      boolean _lessThan_1 = (_max < 0);
      if (_lessThan_1) {
        this.error("The maximum must be greater than 0", JavaRulePackage.Literals.RANGO_NAMES__MAX, "invalidMin");
      }
      int _min_1 = t.getMin();
      int _max_1 = t.getMax();
      boolean _greaterThan = (_min_1 > _max_1);
      if (_greaterThan) {
        this.error("The minimum can\'t be greater than the maximum", JavaRulePackage.Literals.RANGO_NAMES__MAX, 
          "invalidMin");
      }
    }
  }
  
  @Check
  public void checkVariableExistsBefore(final Sentence s) {
    EList<Variable> in = s.getIn();
    Variable from = s.getFrom();
    EList<VariableSubtype> using = s.getUsing();
    for (final Variable v : in) {
      boolean _isDeclaredBefore = this.isDeclaredBefore(v, s);
      boolean _not = (!_isDeclaredBefore);
      if (_not) {
        String _name = v.getName();
        String _plus = ("The variable " + _name);
        String _plus_1 = (_plus + " must be declared before this sentence");
        this.error(_plus_1, JavaRulePackage.Literals.SENTENCE__IN, 
          "invalidMin");
      }
    }
    boolean _notEquals = (!Objects.equal(from, null));
    if (_notEquals) {
      boolean _isDeclaredBefore_1 = this.isDeclaredBefore(from, s);
      boolean _not_1 = (!_isDeclaredBefore_1);
      if (_not_1) {
        String _name_1 = from.getName();
        String _plus_2 = ("The variable " + _name_1);
        String _plus_3 = (_plus_2 + " must be declared before this sentence");
        this.error(_plus_3, JavaRulePackage.Literals.SENTENCE__FROM, 
          "invalidMin");
      }
    }
    for (final VariableSubtype v_1 : using) {
      Variable _variable = v_1.getVariable();
      boolean _isDeclaredBefore_2 = this.isDeclaredBefore(_variable, s);
      boolean _not_2 = (!_isDeclaredBefore_2);
      if (_not_2) {
        Variable _variable_1 = v_1.getVariable();
        String _name_2 = _variable_1.getName();
        String _plus_4 = ("The variable " + _name_2);
        String _plus_5 = (_plus_4 + " must be declared before this sentence");
        this.error(_plus_5, JavaRulePackage.Literals.SENTENCE__IN, 
          "invalidMin");
      }
    }
  }
  
  public boolean isDeclaredBefore(final Variable variable, final Sentence sentence) {
    boolean _xblockexpression = false;
    {
      EObject container = this.getSentenceOrRuleSet(sentence);
      boolean _xifexpression = false;
      if ((container instanceof Sentence)) {
        _xifexpression = this.isDeclaredBefore(variable, ((Sentence)container));
      } else {
        RuleSet ruleSet = ((RuleSet) container);
        EList<Sentence> _sentences = ruleSet.getSentences();
        for (final Sentence s : _sentences) {
          {
            boolean _equals = s.equals(sentence);
            if (_equals) {
              return false;
            }
            boolean _equals_1 = s.equals(variable);
            if (_equals_1) {
              return true;
            }
          }
        }
        return false;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  public RuleSet getRuleSet(final Sentence s) {
    EObject container = s.eContainer();
    boolean flag = true;
    while (flag) {
      {
        if ((container instanceof RuleSet)) {
          return ((RuleSet)container);
        }
        EObject _eContainer = container.eContainer();
        container = _eContainer;
      }
    }
    return null;
  }
}

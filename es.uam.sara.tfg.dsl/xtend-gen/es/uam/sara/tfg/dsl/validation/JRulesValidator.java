/**
 * generated by Xtext 2.10.0
 */
package es.uam.sara.tfg.dsl.validation;

import com.google.common.base.Objects;
import es.uam.sara.tfg.dsl.validation.AbstractJRulesValidator;
import javaRule.AccessModifier;
import javaRule.And;
import javaRule.Attribute;
import javaRule.BlendModifiers;
import javaRule.Contains;
import javaRule.ElementJava;
import javaRule.Enumeration;
import javaRule.Filter;
import javaRule.Implements;
import javaRule.Interface;
import javaRule.JavaDoc;
import javaRule.JavaRulePackage;
import javaRule.Language;
import javaRule.Method;
import javaRule.NameOperation;
import javaRule.NameOperator;
import javaRule.Or;
import javaRule.Parameter;
import javaRule.Quantifier;
import javaRule.Rule;
import javaRule.RuleSet;
import javaRule.Satisfy;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IWorkspace;
import org.eclipse.core.resources.IWorkspaceRoot;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Conversions;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class JRulesValidator extends AbstractJRulesValidator {
  public final static String INVALID_SATISFY = "invalidSatisfy";
  
  @Check
  public void checkProject(final RuleSet rs) {
    EList<String> _projectName = rs.getProjectName();
    boolean _isEmpty = _projectName.isEmpty();
    if (_isEmpty) {
      this.error("You must put a name Project", JavaRulePackage.Literals.RULE_SET__PROJECT_NAME, "invalidProject");
    } else {
      IWorkspace _workspace = ResourcesPlugin.getWorkspace();
      IWorkspaceRoot workspace = _workspace.getRoot();
      EList<String> _projectName_1 = rs.getProjectName();
      for (final String name : _projectName_1) {
        boolean _equals = Objects.equal(name, "");
        if (_equals) {
          this.error((("The project " + name) + " is not into worksapce"), 
            JavaRulePackage.Literals.RULE_SET__PROJECT_NAME, "invalidProject");
        } else {
          IProject project = workspace.getProject(name);
          boolean _exists = project.exists();
          boolean _not = (!_exists);
          if (_not) {
            this.error((("The project " + name) + " is not into worksapce"), 
              JavaRulePackage.Literals.RULE_SET__PROJECT_NAME, "invalidProject");
          }
        }
      }
    }
  }
  
  @Check
  public void checkSatisfyExists(final Rule r) {
    boolean _and = false;
    EObject _eContainer = r.eContainer();
    if (!(_eContainer instanceof RuleSet)) {
      _and = false;
    } else {
      Or _satisfy = r.getSatisfy();
      boolean _equals = Objects.equal(_satisfy, null);
      _and = _equals;
    }
    if (_and) {
      this.error("\"Satisfy\" is required", JavaRulePackage.Literals.RULE__QUANTIFIER, "invalidRule");
    } else {
      boolean _and_1 = false;
      Quantifier _quantifier = r.getQuantifier();
      boolean _equals_1 = Objects.equal(_quantifier, Quantifier.ALL);
      if (!_equals_1) {
        _and_1 = false;
      } else {
        Or _satisfy_1 = r.getSatisfy();
        boolean _equals_2 = Objects.equal(_satisfy_1, null);
        _and_1 = _equals_2;
      }
      if (_and_1) {
        this.error("\"Satisfy\" is required with quantifier all", JavaRulePackage.Literals.RULE__QUANTIFIER, "invalidRule");
      }
    }
    boolean _and_2 = false;
    Or _satisfy_2 = r.getSatisfy();
    boolean _equals_3 = Objects.equal(_satisfy_2, null);
    if (!_equals_3) {
      _and_2 = false;
    } else {
      Filter _filter = r.getFilter();
      boolean _notEquals = (!Objects.equal(_filter, null));
      _and_2 = _notEquals;
    }
    if (_and_2) {
      this.error("\"Satisfy\" is required after clause \"which\"", JavaRulePackage.Literals.RULE__FILTER, 
        "invalidRule");
    }
  }
  
  @Check
  public void checkFilterValido(final Rule r) {
    Filter _filter = r.getFilter();
    Or _filter_1 = _filter.getFilter();
    ElementJava _element = r.getElement();
    boolean _comprobarPropiedades = this.comprobarPropiedades(_filter_1, _element);
    boolean _equals = (_comprobarPropiedades == false);
    if (_equals) {
      ElementJava _element_1 = r.getElement();
      String _literal = _element_1.getLiteral();
      String _lowerCase = _literal.toLowerCase();
      String _plus = ("The filter is not valid for " + _lowerCase);
      this.error(_plus, 
        JavaRulePackage.Literals.RULE__ELEMENT, JRulesValidator.INVALID_SATISFY);
    }
  }
  
  @Check
  public void checkSatisfyType(final Rule r) {
    Or _satisfy = r.getSatisfy();
    ElementJava _element = r.getElement();
    boolean _comprobarPropiedades = this.comprobarPropiedades(_satisfy, _element);
    boolean _equals = (_comprobarPropiedades == false);
    if (_equals) {
      ElementJava _element_1 = r.getElement();
      String _literal = _element_1.getLiteral();
      String _lowerCase = _literal.toLowerCase();
      String _plus = ("The property is not valid for " + _lowerCase);
      this.error(_plus, 
        JavaRulePackage.Literals.RULE__ELEMENT, 
        JRulesValidator.INVALID_SATISFY);
    }
  }
  
  public boolean comprobarPropiedades(final Or or, final ElementJava e) {
    EList<And> _op = or.getOp();
    for (final And a : _op) {
      EList<Satisfy> _op_1 = a.getOp();
      for (final Satisfy s : _op_1) {
        boolean _comprobarSatisfy = this.comprobarSatisfy(e, s);
        boolean _equals = (_comprobarSatisfy == false);
        if (_equals) {
          return false;
        }
      }
    }
    return true;
  }
  
  public boolean comprobarSatisfy(final ElementJava e, final Satisfy s) {
    boolean _and = false;
    boolean _equals = Objects.equal(e, ElementJava.PACKAGE);
    if (!_equals) {
      _and = false;
    } else {
      _and = (s instanceof javaRule.Package);
    }
    if (_and) {
      return true;
    } else {
      boolean _and_1 = false;
      boolean _equals_1 = Objects.equal(e, ElementJava.INTERFACE);
      if (!_equals_1) {
        _and_1 = false;
      } else {
        _and_1 = (s instanceof Interface);
      }
      if (_and_1) {
        return true;
      } else {
        boolean _and_2 = false;
        boolean _equals_2 = Objects.equal(e, ElementJava.CLASS);
        if (!_equals_2) {
          _and_2 = false;
        } else {
          _and_2 = (s instanceof javaRule.Class);
        }
        if (_and_2) {
          return true;
        } else {
          boolean _and_3 = false;
          boolean _equals_3 = Objects.equal(e, ElementJava.ENUM);
          if (!_equals_3) {
            _and_3 = false;
          } else {
            _and_3 = (s instanceof Enumeration);
          }
          if (_and_3) {
            return true;
          } else {
            boolean _and_4 = false;
            boolean _equals_4 = Objects.equal(e, ElementJava.METHOD);
            if (!_equals_4) {
              _and_4 = false;
            } else {
              _and_4 = (s instanceof Method);
            }
            if (_and_4) {
              return true;
            } else {
              boolean _and_5 = false;
              boolean _equals_5 = Objects.equal(e, ElementJava.ATTRIBUTE);
              if (!_equals_5) {
                _and_5 = false;
              } else {
                _and_5 = (s instanceof Attribute);
              }
              if (_and_5) {
                return true;
              } else {
                return false;
              }
            }
          }
        }
      }
    }
  }
  
  @Check
  public void checkNameLanguage(final NameOperation n) {
    boolean _and = false;
    NameOperator _operator = n.getOperator();
    boolean _equals = Objects.equal(_operator, NameOperator.LIKE);
    if (!_equals) {
      _and = false;
    } else {
      Language _language = n.getLanguage();
      boolean _equals_1 = Objects.equal(_language, Language.EMPTY);
      _and = _equals_1;
    }
    if (_and) {
      this.error(
        "Language must be define for Like operator", 
        JavaRulePackage.Literals.NAME_OPERATION__OPERATOR, 
        "invalidLanguage");
    }
    boolean _and_1 = false;
    NameOperator _operator_1 = n.getOperator();
    boolean _notEquals = (!Objects.equal(_operator_1, NameOperator.LIKE));
    if (!_notEquals) {
      _and_1 = false;
    } else {
      Language _language_1 = n.getLanguage();
      boolean _notEquals_1 = (!Objects.equal(_language_1, Language.EMPTY));
      _and_1 = _notEquals_1;
    }
    if (_and_1) {
      this.error(
        "Language is only for Like operator", 
        JavaRulePackage.Literals.NAME_OPERATION__LANGUAGE, 
        "invalidLanguage");
    }
  }
  
  @Check
  public void checkJavaDoc(final JavaDoc jd) {
    Rule rule = this.getRule(jd);
    boolean _and = false;
    ElementJava _element = rule.getElement();
    boolean _notEquals = (!Objects.equal(_element, ElementJava.METHOD));
    if (!_notEquals) {
      _and = false;
    } else {
      boolean _isParameter = jd.isParameter();
      _and = _isParameter;
    }
    if (_and) {
      this.warning("The tag @parameter is used for methods", JavaRulePackage.Literals.JAVA_DOC__PARAMETER, 
        "inadvisableJavaDoc");
    }
    boolean _and_1 = false;
    ElementJava _element_1 = rule.getElement();
    boolean _notEquals_1 = (!Objects.equal(_element_1, ElementJava.METHOD));
    if (!_notEquals_1) {
      _and_1 = false;
    } else {
      boolean _isReturn = jd.isReturn();
      _and_1 = _isReturn;
    }
    if (_and_1) {
      this.warning("The tag @return is used for methods", JavaRulePackage.Literals.JAVA_DOC__RETURN, 
        "inadvisableJavaDoc");
    }
    boolean _and_2 = false;
    ElementJava _element_2 = rule.getElement();
    boolean _notEquals_2 = (!Objects.equal(_element_2, ElementJava.METHOD));
    if (!_notEquals_2) {
      _and_2 = false;
    } else {
      boolean _isThrows = jd.isThrows();
      _and_2 = _isThrows;
    }
    if (_and_2) {
      this.warning("The tag @throws is used for methods", JavaRulePackage.Literals.JAVA_DOC__THROWS, 
        "inadvisableJavaDoc");
    }
  }
  
  public Rule getRule(final JavaDoc jd) {
    EObject _eContainer = jd.eContainer();
    EObject _eContainer_1 = _eContainer.eContainer();
    EObject aux1 = _eContainer_1.eContainer();
    EObject _eContainer_2 = jd.eContainer();
    EObject _eContainer_3 = _eContainer_2.eContainer();
    EObject _eContainer_4 = _eContainer_3.eContainer();
    EObject aux2 = _eContainer_4.eContainer();
    if ((aux1 instanceof Rule)) {
      Rule rule = ((Rule) aux1);
      return rule;
    } else {
      if ((aux2 instanceof Rule)) {
        Rule rule_1 = ((Rule) aux2);
        return rule_1;
      }
    }
    return null;
  }
  
  public Rule getRule(final BlendModifiers b) {
    EObject _eContainer = b.eContainer();
    EObject _eContainer_1 = _eContainer.eContainer();
    EObject _eContainer_2 = _eContainer_1.eContainer();
    EObject aux1 = _eContainer_2.eContainer();
    EObject _eContainer_3 = b.eContainer();
    EObject _eContainer_4 = _eContainer_3.eContainer();
    EObject _eContainer_5 = _eContainer_4.eContainer();
    EObject _eContainer_6 = _eContainer_5.eContainer();
    EObject aux2 = _eContainer_6.eContainer();
    if ((aux1 instanceof Rule)) {
      Rule rule = ((Rule) aux1);
      return rule;
    } else {
      if ((aux2 instanceof Rule)) {
        Rule rule_1 = ((Rule) aux2);
        return rule_1;
      }
    }
    return null;
  }
  
  @Check
  public void checkModifiers(final BlendModifiers b) {
    Rule r = this.getRule(b);
    boolean _accessPrivateProtecte = this.accessPrivateProtecte(b);
    if (_accessPrivateProtecte) {
      boolean _or = false;
      boolean _or_1 = false;
      ElementJava _element = r.getElement();
      boolean _equals = Objects.equal(_element, ElementJava.CLASS);
      if (_equals) {
        _or_1 = true;
      } else {
        ElementJava _element_1 = r.getElement();
        boolean _equals_1 = Objects.equal(_element_1, ElementJava.INTERFACE);
        _or_1 = _equals_1;
      }
      if (_or_1) {
        _or = true;
      } else {
        ElementJava _element_2 = r.getElement();
        boolean _equals_2 = Objects.equal(_element_2, ElementJava.ENUM);
        _or = _equals_2;
      }
      if (_or) {
        this.warning("The private and protected modifiers are for classes, interfaces and enumeration internal", 
          JavaRulePackage.Literals.BLEND_MODIFIERS__ACCESS, "inadvisableModifier");
      }
    }
    boolean _isAbstract = b.isAbstract();
    if (_isAbstract) {
      ElementJava _element_3 = r.getElement();
      boolean _equals_3 = Objects.equal(_element_3, ElementJava.INTERFACE);
      if (_equals_3) {
        this.warning("The interfaces are implicitly abstract, its not necessary add the modifier", 
          JavaRulePackage.Literals.BLEND_MODIFIERS__ABSTRACT, "inadvisableModifier");
      } else {
        boolean _and = false;
        ElementJava _element_4 = r.getElement();
        boolean _notEquals = (!Objects.equal(_element_4, ElementJava.CLASS));
        if (!_notEquals) {
          _and = false;
        } else {
          ElementJava _element_5 = r.getElement();
          boolean _notEquals_1 = (!Objects.equal(_element_5, ElementJava.METHOD));
          _and = _notEquals_1;
        }
        if (_and) {
          this.error("Abstract is for methods and class", JavaRulePackage.Literals.BLEND_MODIFIERS__ABSTRACT, 
            "invalidModifier");
        } else {
          boolean _isFinal = b.isFinal();
          if (_isFinal) {
            this.error("Methods and Class can\'t be abstract and final simultaneously", 
              JavaRulePackage.Literals.BLEND_MODIFIERS__ABSTRACT, "invalidModifier");
          }
        }
      }
    }
    boolean _isFinal_1 = b.isFinal();
    if (_isFinal_1) {
      boolean _or_2 = false;
      ElementJava _element_6 = r.getElement();
      boolean _equals_4 = Objects.equal(_element_6, ElementJava.INTERFACE);
      if (_equals_4) {
        _or_2 = true;
      } else {
        ElementJava _element_7 = r.getElement();
        boolean _equals_5 = Objects.equal(_element_7, ElementJava.ENUM);
        _or_2 = _equals_5;
      }
      if (_or_2) {
        this.error("Final is for methods, class and attributes", JavaRulePackage.Literals.BLEND_MODIFIERS__FINAL, 
          "invalidModifier");
      }
    }
    boolean _isStatic = b.isStatic();
    if (_isStatic) {
      boolean _or_3 = false;
      boolean _or_4 = false;
      ElementJava _element_8 = r.getElement();
      boolean _equals_6 = Objects.equal(_element_8, ElementJava.CLASS);
      if (_equals_6) {
        _or_4 = true;
      } else {
        ElementJava _element_9 = r.getElement();
        boolean _equals_7 = Objects.equal(_element_9, ElementJava.INTERFACE);
        _or_4 = _equals_7;
      }
      if (_or_4) {
        _or_3 = true;
      } else {
        ElementJava _element_10 = r.getElement();
        boolean _equals_8 = Objects.equal(_element_10, ElementJava.ENUM);
        _or_3 = _equals_8;
      }
      if (_or_3) {
        this.warning("Static is for classes, interfaces and enumeration internal", 
          JavaRulePackage.Literals.BLEND_MODIFIERS__ACCESS, "inadvisableModifier");
      }
    }
    boolean _and_1 = false;
    boolean _isSynchronized = b.isSynchronized();
    if (!_isSynchronized) {
      _and_1 = false;
    } else {
      ElementJava _element_11 = r.getElement();
      boolean _notEquals_2 = (!Objects.equal(_element_11, ElementJava.METHOD));
      _and_1 = _notEquals_2;
    }
    if (_and_1) {
      this.error("Synchronized is for methods", JavaRulePackage.Literals.BLEND_MODIFIERS__SYNCHRONIZED, 
        "invalidModifier");
    }
  }
  
  public boolean accessPrivateProtecte(final BlendModifiers b) {
    boolean _or = false;
    AccessModifier _access = b.getAccess();
    boolean _equals = Objects.equal(_access, AccessModifier.PRIVATE);
    if (_equals) {
      _or = true;
    } else {
      AccessModifier _access_1 = b.getAccess();
      boolean _equals_1 = Objects.equal(_access_1, AccessModifier.PROTECTED);
      _or = _equals_1;
    }
    if (_or) {
      return true;
    }
    return false;
  }
  
  @Check
  public void checkContains(final Contains c) {
    Rule r = this.getRule(c);
    ElementJava _element = r.getElement();
    boolean _equals = Objects.equal(_element, ElementJava.PACKAGE);
    if (_equals) {
      boolean _or = false;
      boolean _or_1 = false;
      Rule _which = c.getWhich();
      ElementJava _element_1 = _which.getElement();
      boolean _equals_1 = Objects.equal(_element_1, ElementJava.METHOD);
      if (_equals_1) {
        _or_1 = true;
      } else {
        Rule _which_1 = c.getWhich();
        ElementJava _element_2 = _which_1.getElement();
        boolean _equals_2 = Objects.equal(_element_2, ElementJava.ATTRIBUTE);
        _or_1 = _equals_2;
      }
      if (_or_1) {
        _or = true;
      } else {
        Rule _which_2 = c.getWhich();
        ElementJava _element_3 = _which_2.getElement();
        boolean _equals_3 = Objects.equal(_element_3, ElementJava.PACKAGE);
        _or = _equals_3;
      }
      if (_or) {
        this.error("Package contains Class, Interfaces or Enumerations", JavaRulePackage.Literals.CONTAINS__WHICH, 
          "invalidContains");
      }
    }
  }
  
  public Rule getRule(final Contains c) {
    EObject _eContainer = c.eContainer();
    EObject _eContainer_1 = _eContainer.eContainer();
    EObject aux1 = _eContainer_1.eContainer();
    EObject _eContainer_2 = c.eContainer();
    EObject _eContainer_3 = _eContainer_2.eContainer();
    EObject _eContainer_4 = _eContainer_3.eContainer();
    EObject aux2 = _eContainer_4.eContainer();
    if ((aux1 instanceof Rule)) {
      Rule rule = ((Rule) aux1);
      return rule;
    } else {
      if ((aux2 instanceof Rule)) {
        Rule rule_1 = ((Rule) aux2);
        return rule_1;
      }
    }
    return null;
  }
  
  @Check
  public void checkImplements(final Implements i) {
    int _minInterface = i.getMinInterface();
    boolean _lessThan = (_minInterface < 0);
    if (_lessThan) {
      this.error("The minimum of interfaces must be greater than 0", 
        JavaRulePackage.Literals.IMPLEMENTS__MIN_INTERFACE, "invalidMin");
    }
    int _maxInterface = i.getMaxInterface();
    boolean _lessThan_1 = (_maxInterface < 0);
    if (_lessThan_1) {
      this.error("The maximum of interfaces must be greater than 0", 
        JavaRulePackage.Literals.IMPLEMENTS__MAX_INTERFACE, "invalidMin");
    }
    int _minInterface_1 = i.getMinInterface();
    int _maxInterface_1 = i.getMaxInterface();
    boolean _greaterThan = (_minInterface_1 > _maxInterface_1);
    if (_greaterThan) {
      this.error("The minimum of interfaces can\'t be greater than the maximum", 
        JavaRulePackage.Literals.IMPLEMENTS__MIN_INTERFACE, "invalidMin");
    }
  }
  
  @Check
  public void checkParameters(final Parameter p) {
    EList<String> _typesParam = p.getTypesParam();
    int _length = ((Object[])Conversions.unwrapArray(_typesParam, Object.class)).length;
    boolean _notEquals = (_length != 0);
    if (_notEquals) {
      EList<String> _typesParam_1 = p.getTypesParam();
      int _length_1 = ((Object[])Conversions.unwrapArray(_typesParam_1, Object.class)).length;
      int _numParam = p.getNumParam();
      boolean _notEquals_1 = (_length_1 != _numParam);
      if (_notEquals_1) {
        this.error("The number of parameters should be equal to the number of types", 
          JavaRulePackage.Literals.PARAMETER__NUM_PARAM, "invalidMin");
      }
    }
  }
}
